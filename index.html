<script>
    const gridSize = 5;
    const qwertyMap = 'QWERTYUIOPASDFGHJKLZXCVBN';
    const initialPoints = 10;
    let currentPoints;
    let mineIndex;
    let revealedCells = 0;
    let gameEnded = false;
    
    // --- NEW MONEY SYSTEM VARIABLES ---
    let currentMultiplier = 1; // Starts at 1x
    const multiplierIncrease = 0.2; // Multiplier increases by 0.2 after each safe reveal
    const basePointRange = [2, 4]; // Safe reveals earn 2 to 4 points

    function generateMine() {
        mineIndex = Math.floor(Math.random() * (gridSize * gridSize));
    }

    function createGrid() {
        // ... (Grid creation logic remains the same)
        const grid = document.getElementById("grid");
        grid.innerHTML = "";
        for (let i = 0; i < gridSize * gridSize; i++) {
            const cell = document.createElement("div");
            cell.classList.add("cell");
            cell.dataset.index = i;

            const cellInner = document.createElement("div");
            cellInner.classList.add("cell-inner");

            const cellFront = document.createElement("div");
            cellFront.classList.add("cell-front");
            cellFront.innerText = qwertyMap[i]; 
            
            const cellBack = document.createElement("div");
            cellBack.classList.add("cell-back");
            cellBack.innerHTML = (i === mineIndex) ? 'üí£' : '‚≠ê'; 

            cellInner.appendChild(cellFront);
            cellInner.appendChild(cellBack);
            cell.appendChild(cellInner);

            cell.addEventListener("click", () => revealCell(i));
            grid.appendChild(cell);
        }
    }

    function updateStatus() {
        // Display both points and multiplier
        document.getElementById("status").innerText = `Current Points: ${currentPoints} | Multiplier: x${currentMultiplier.toFixed(1)}`;
    }

    function revealCell(index) {
        if (gameEnded) return;
        
        const cell = document.querySelector(`.cell[data-index='${index}']`);
        if (!cell || cell.classList.contains("revealed")) return;

        cell.classList.add("revealed");

        if (index === mineIndex) {
            // --- MINE HIT LOGIC (Risk/Reward) ---
            const penalty = Math.max(5, Math.floor(currentPoints / 2)); // Lose 5 or half your points, whichever is greater
            currentPoints -= penalty;
            
            // **Bank System:** Reset multiplier on mine hit
            currentMultiplier = 1; 
            
            cell.classList.add("mine");
            updateStatus();
            checkEndGame();
        } else {
            // --- SAFE CLICK LOGIC (Variable Reward + Multiplier) ---
            const basePoints = Math.floor(Math.random() * (basePointRange[1] - basePointRange[0] + 1)) + basePointRange[0];
            const earnedPoints = Math.floor(basePoints * currentMultiplier);
            
            currentPoints += earnedPoints;
            revealedCells++;
            
            // Increase the multiplier for the next click
            currentMultiplier += multiplierIncrease;
            
            updateStatus();
            checkVictory();
        }
    }

    function freezeBoard() {
        document.querySelectorAll(".cell").forEach(cell => cell.style.pointerEvents = "none");
    }

    function checkVictory() {
        if (revealedCells === gridSize * gridSize - 1) {
            document.getElementById("endMessage").innerText = "üèÜ Victory! All Safe Boxes Found!";
            document.getElementById("finalScore").innerText = `Final Score: ${currentPoints} (Multiplier: x${currentMultiplier.toFixed(1)})`;
            document.getElementById("endScreen").classList.remove("hidden");
            gameEnded = true;
            freezeBoard();
        }
    }

    function checkEndGame() {
        if (currentPoints <= 0) {
            document.getElementById("endMessage").innerText = "üí• Game Over! You ran out of points.";
            document.getElementById("finalScore").innerText = `Final Score: ${currentPoints} (Multiplier reset)`;
            document.getElementById("endScreen").classList.remove("hidden");
            gameEnded = true;
            freezeBoard();
        }
    }

    function resetGame() {
        currentPoints = initialPoints; // Reset points
        revealedCells = 0;
        gameEnded = false;
        currentMultiplier = 1; // Reset multiplier
        generateMine();
        createGrid();
        updateStatus();
        document.getElementById("endScreen").classList.add("hidden");
        document.querySelectorAll(".cell").forEach(cell => cell.style.pointerEvents = "auto");
    }
    
    // --- Keyboard Input Feature (QWERTY Map) ---
    document.addEventListener('keydown', (event) => {
        if (gameEnded) return;
        
        const key = event.key.toUpperCase();
        const index = qwertyMap.indexOf(key); 

        if (index !== -1) {
            const cell = document.querySelector(`.cell[data-index='${index}']`);
            if (cell && !cell.classList.contains("revealed")) {
                 revealCell(index);
            }
        }
    });

    document.getElementById("resetButton").addEventListener("click", resetGame);

    // Initial setup
    resetGame(); 
</script>
